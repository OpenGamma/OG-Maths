/**
 * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for licence.
 *
 */

#include "dispatch.hh"
#include "runners.hh"
#include "expression.hh"
#include "iss.hh"
#include "terminal.hh"
#include "uncopyable.hh"
#include "lapack.hh"

#include <stdio.h>
#include <complex>
#include <sstream>

/**
 * Unit contains code for custom (i.e. non-autogenerated) runners
 */
namespace librdag {

void *
NORM2Runner::run(RegContainer * reg, OGRealScalar const * arg) const
{
  const OGRealScalar* ret;
  ret = new OGRealScalar(fabs(arg->getValue()));
  reg->push_back(ret);
  return nullptr;
}
void *
NORM2Runner::run(RegContainer * reg, OGRealMatrix const * arg) const
{
  const OGRealScalar* ret = nullptr; // the returned item

  // Matrix in scalar context, i.e. a 1x1 matrix, norm2 is simply abs(value)
  if(arg->getRows()==1 && arg->getCols()==1)
  {
    ret = new OGRealScalar(fabs(arg->getData()[0]));
  }
  else if(isVector(arg)) // Matrix is a vector, norm2 computed via BLAS dnrm2
  {
    int one = 1;
    int len = arg->getRows() > arg->getCols() ? arg->getRows(): arg->getCols();
    real16 value = F77FUNC(dnrm2)(&len, arg->getData(), &one);
    ret = new OGRealScalar(value);
  }
  else // Matrix is a full matrix, norm2 computed via LAPACK dgesvd
  {
    int m = arg->getRows();
    int n = arg->getCols();
    int lda = m > 1 ? m : 1;
    int ldu = lda;
    int minmn = m > n ? n : m;
    int ldvt = minmn;
    int lwork = -1; // set for query
    int info = 0;

    real16 * tmp = new real16[1];
    real16 * U = nullptr; //IGNORED
    real16 * VT = nullptr; //IGNORED
    real16 * S = new real16[minmn];

    real16 * WORK = tmp; // set properly after query, alloc slot of 1 needed as the work space dimension is written here.

    char optN = 'N';

    // copy A else it's destroyed
    real16 * A = new real16[m*n];
    std::memcpy(A, arg->getData(), sizeof(real16)*m*n);

    // query workspace
    F77FUNC(dgesvd)(&optN, &optN, &m, &n, A, &lda, S, U, &ldu, VT, &ldvt, WORK, &lwork, &info);

    // set workspace
    lwork = (int)WORK[0];
    WORK = new real16[lwork];

    // finally, the call
    F77FUNC(dgesvd)(&optN, &optN, &m, &n, A, &lda, S, U, &ldu, VT, &ldvt, WORK, &lwork, &info);

    if(info!=0)
    {
      if(info < 0)
      {
        stringstream message;
        message << "Input to LAPACK::dgesvd call incorrect at arg: " << info;
        throw rdag_error(message.str());
      }
      else
      {
        throw rdag_error("LAPACK::dgesvd, internal call to dbdsqr did not converge.");
      }
    }

    ret = new OGRealScalar(S[0]);
    delete[] tmp;
    delete[] A;
    delete[] S;
    delete[] WORK;
  }

  // shove ret into register
  reg->push_back(ret);
  return nullptr;
}

void *
NORM2Runner::run(RegContainer * reg, OGComplexMatrix const * arg) const
{
  const OGRealScalar* ret = nullptr; // the returned item

  // Matrix in scalar context, i.e. a 1x1 matrix, norm2 is simply abs(value)
  if(arg->getRows()==1 && arg->getCols()==1)
  {
    ret = new OGRealScalar(std::abs(arg->getData()[0]));
  }
  else if(isVector(arg)) // Matrix is a vector, norm2 computed via BLAS dznrm2
  {
    int one = 1;
    int len = arg->getRows() > arg->getCols() ? arg->getRows(): arg->getCols();
    real16 value = F77FUNC(dznrm2)(&len, arg->getData(), &one);
    ret = new OGRealScalar(value);
  }
  else // Matrix is a full matrix, norm2 computed via LAPACK zgesvd
  {
    int m = arg->getRows();
    int n = arg->getCols();
    int lda = m > 1 ? m : 1;
    int ldu = lda;
    int minmn = m > n ? n : m;
    int ldvt = minmn;
    int lwork = -1; // set for query
    int info = 0;

    complex16 * tmp = new complex16[1];
    complex16 * U = nullptr; //IGNORED
    complex16 * VT = nullptr; //IGNORED
    real16    * S = new real16[minmn];
    real16    * RWORK = new real16[5*minmn];
    complex16 * WORK = tmp; // set properly after query, alloc slot of 1 needed as the work space dimension is written here.

    char optN = 'N';

    // copy A else it's destroyed
    complex16 * A = new complex16[m*n];
    std::memcpy(A, arg->getData(), sizeof(complex16)*m*n);

    // query workspace
    F77FUNC(zgesvd)(&optN, &optN, &m, &n, A, &lda, S, U, &ldu, VT, &ldvt, WORK, &lwork, RWORK, &info);

    // set workspace
    lwork = (int)(WORK[0].real());
    WORK = new complex16[lwork];

    // finally, the call
    F77FUNC(zgesvd)(&optN, &optN, &m, &n, A, &lda, S, U, &ldu, VT, &ldvt, WORK, &lwork, RWORK, &info);

    if(info!=0)
    {
      if(info < 0)
      {
        stringstream message;
        message << "Input to LAPACK::zgesvd call incorrect at arg: " << info;
        throw rdag_error(message.str());
      }
      else
      {
        throw rdag_error("LAPACK::zgesvd, internal call to zbdsqr did not converge.");
      }
    }

    ret = new OGRealScalar(std::real(S[0]));
    delete[] tmp;
    delete[] A;
    delete[] S;
    delete[] RWORK;
    delete[] WORK;
  }

  // shove ret into register
  reg->push_back(ret);
  return nullptr;
}


// MTIMES runner:
void * MTIMESRunner::run(RegContainer SUPPRESS_UNUSED * reg0, const OGComplexMatrix SUPPRESS_UNUSED * arg0, const OGComplexMatrix SUPPRESS_UNUSED * arg1) const
{

    return nullptr;
}

void * MTIMESRunner::run(RegContainer* reg0, const OGRealMatrix*    arg0, const OGRealMatrix*    arg1) const
{
  int colsArray1 = arg0->getCols();
  int colsArray2 = arg1->getCols();
  int rowsArray1 = arg0->getRows();
  int rowsArray2 = arg1->getRows();
  real16 * data1 = arg0->getData();
  real16 * data2 = arg1->getData();

  real16 * tmp = nullptr;

  // Fortran vars
  int one = 1;
  char N = 'N';
  real16 real_one = 1.e0;

  OGTerminal * ret = nullptr;

  if (colsArray1 == 1 && rowsArray1 == 1) { // We have scalar * matrix
    real16 deref = data1[0];
    int n = rowsArray2 * colsArray2;
    tmp = new real16[n];
    memcpy(tmp,data2,n*sizeof(real16));
    F77FUNC(dscal)(&n,&deref,tmp,&one);
    ret = new OGOwningRealMatrix(tmp, rowsArray2, colsArray2);
  } else if (colsArray2 == 1 && rowsArray2 == 1) { // We have matrix * scalar
    real16 deref = data2[0];
    int n = rowsArray1 * colsArray1;
    tmp = new real16[n];
    memcpy(tmp,data1,n*sizeof(real16));
    F77FUNC(dscal)(&n,&deref,tmp,&one);
    ret = new OGOwningRealMatrix(tmp, rowsArray1, colsArray1);
  } else {
    if(colsArray1!=rowsArray2)
    {
      stringstream message;
      message << "Matrices do not commute. First is: " << rowsArray1 <<"x"<< colsArray1 <<". Second is: " << rowsArray2 <<"x"<< colsArray2;
      throw rdag_error(message.str());
    }
    if (colsArray2 == 1) { // A*x
      tmp = new real16[rowsArray1]();
      F77FUNC(dgemv)(&N, &rowsArray1, &colsArray1, &real_one, data1, &rowsArray1, data2, &one, &real_one, tmp, &one);
      ret = new OGOwningRealMatrix(tmp, rowsArray1, 1);
    } else {
      int fm = rowsArray1;
      int fn = colsArray2;
      int fk = colsArray1;
      real16 alpha = 1.e0;
      int lda = fm;
      int ldb = fk;
      real16 beta = 0.e0;
      tmp = new real16[fm * fn];
      int ldc = fm;
      F77FUNC(dgemm)(&N, &N, &fm, &fn, &fk, &alpha, data1, &lda, data2, &ldb, &beta, tmp, &ldc);
      ret = new OGOwningRealMatrix(tmp, fm, fn);
    }
  }
  ret->debug_print();
  // shove ret into register
  reg0->push_back(ret);
  return nullptr;
}

void *
MTIMESRunner::run(RegContainer SUPPRESS_UNUSED * reg0, const OGRealScalar SUPPRESS_UNUSED *    arg0, const OGRealScalar SUPPRESS_UNUSED *    arg1) const
{
    OGTerminal * ret = new OGRealScalar(arg0->getValue()*arg1->getValue());
    reg0->push_back(ret);
    return nullptr;
}

} // end namespace
