/**
 * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */

#include <iostream>
#include "expressionbase.hh"
#include "expression.hh"
#include "terminal.hh"
#include "exceptions.hh"

using namespace std;

namespace librdag
{

/*
 * OGExpr
 */

OGExpr::OGExpr() {}

OGExpr::~OGExpr() {}

const ArgContainer&
OGExpr::getArgs() const
{
  return _args;
}

size_t
OGExpr::getNArgs() const
{
  return _args.size();
}

OGExpr::Ptr
OGExpr::asOGExpr() const
{
  return static_pointer_cast<const OGExpr, const OGNumeric>(shared_from_this());
}

RegContainer&
OGExpr::getRegs() const
{
  return _regs;
}

void OGExpr::debug_print() const
{
  cout << "OGExpr::debug_print()" << std::endl;
}


/**
 * Things that extend OGExpr
 */

OGUnaryExpr::OGUnaryExpr(const OGNumeric::Ptr& arg): OGExpr{}
{
  if (arg == OGNumeric::Ptr{})
  {
    throw rdag_error("Null operand passed to unary expression");
  }
  _args.push_back(arg);
}

OGBinaryExpr::OGBinaryExpr(const OGNumeric::Ptr& arg0, const OGNumeric::Ptr& arg1): OGExpr{}
{
  if (arg0 == nullptr)
  {
    throw rdag_error("Null operand passed to binary expression in arg0");
  }
  if (arg1 == nullptr)
  {
    throw rdag_error("Null operand passed to binary expression in arg1");
  }
  _args.push_back(arg0);
  _args.push_back(arg1);
}

/**
 * Non autogenerated nodes
 */

/**
 * COPY node
 */

COPY::COPY(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

COPY::Ptr
COPY::create(const OGNumeric::Ptr& arg)
{
  return COPY::Ptr{new COPY{arg}};
}

OGNumeric::Ptr
COPY::copy() const
{
  return OGNumeric::Ptr{new COPY(_args[0]->copy())};
}

COPY::Ptr
COPY::asCOPY() const
{
  return static_pointer_cast<const COPY, const OGNumeric>(shared_from_this());
}

void
COPY::debug_print() const
{
        cout << "COPY base class" << endl;
}

ExprType_t
COPY::getType() const
{
  return COPY_ENUM;
}

/**
 * SELECTRESULT node
 */
SELECTRESULT::SELECTRESULT(const OGNumeric::Ptr& arg0, const OGNumeric::Ptr& arg1): OGExpr{}
{
  if (arg0 == nullptr)
  {
    throw rdag_error("Null operand passed to binary expression in arg0");
  }
  if (arg1 == nullptr)
  {
    throw rdag_error("Null operand passed to binary expression in arg1");
  }
  if (arg1->getType() != INTEGER_SCALAR_ENUM)
  {
    throw rdag_error("Second argument of SelectResult is not an integer");
  }
  _args.push_back(arg0);
  _args.push_back(arg1);
}

SELECTRESULT::Ptr
SELECTRESULT::create(const OGNumeric::Ptr& arg0, const OGNumeric::Ptr& arg1)
{
  return SELECTRESULT::Ptr{new SELECTRESULT{arg0, arg1}};
}

OGNumeric::Ptr
SELECTRESULT::copy() const
{
  return OGNumeric::Ptr{new SELECTRESULT(_args[0]->copy(), _args[1]->copy())};
}

SELECTRESULT::Ptr
SELECTRESULT::asSELECTRESULT() const
{
  return static_pointer_cast<const SELECTRESULT, const OGNumeric>(shared_from_this());
}

void
SELECTRESULT::debug_print() const
{
        printf("SELECTRESULT base class\n");
}

ExprType_t
SELECTRESULT::getType() const
{
  return SELECTRESULT_ENUM;
}


/**
 * NORM2 node
 */

NORM2::NORM2(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

NORM2::Ptr
NORM2::create(const OGNumeric::Ptr& arg)
{
  return NORM2::Ptr{new NORM2{arg}};
}

OGNumeric::Ptr
NORM2::copy() const
{

  return OGNumeric::Ptr{new NORM2(_args[0]->copy())};
}

NORM2::Ptr
NORM2::asNORM2() const
{
  return static_pointer_cast<const NORM2, const OGNumeric>(shared_from_this());
}

void
NORM2::debug_print() const
{
        cout << "NORM2 base class" << endl;
}

ExprType_t
NORM2::getType() const
{
  return NORM2_ENUM;
}

/**
 * PINV node
 */

PINV::PINV(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

PINV::Ptr
PINV::create(const OGNumeric::Ptr& arg)
{
  return PINV::Ptr{new PINV{arg}};
}

OGNumeric::Ptr
PINV::copy() const
{

  return OGNumeric::Ptr{new PINV(_args[0]->copy())};
}

PINV::Ptr
PINV::asPINV() const
{
  return static_pointer_cast<const PINV, const OGNumeric>(shared_from_this());
}

void
PINV::debug_print() const
{
        cout << "PINV base class" << endl;
}

ExprType_t
PINV::getType() const
{
  return PINV_ENUM;
}


/**
 * INV node
 */

INV::INV(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

INV::Ptr
INV::create(const OGNumeric::Ptr& arg)
{
  return INV::Ptr{new INV{arg}};
}

OGNumeric::Ptr
INV::copy() const
{

  return OGNumeric::Ptr{new INV(_args[0]->copy())};
}

INV::Ptr
INV::asINV() const
{
  return static_pointer_cast<const INV, const OGNumeric>(shared_from_this());
}

void
INV::debug_print() const
{
        cout << "INV base class" << endl;
}

ExprType_t
INV::getType() const
{
  return INV_ENUM;
}


/**
 * TRANSPOSE node
 */

TRANSPOSE::TRANSPOSE(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

TRANSPOSE::Ptr
TRANSPOSE::create(const OGNumeric::Ptr& arg)
{
  return TRANSPOSE::Ptr{new TRANSPOSE{arg}};
}

OGNumeric::Ptr
TRANSPOSE::copy() const
{

  return OGNumeric::Ptr{new TRANSPOSE(_args[0]->copy())};
}

TRANSPOSE::Ptr
TRANSPOSE::asTRANSPOSE() const
{
  return static_pointer_cast<const TRANSPOSE, const OGNumeric>(shared_from_this());
}

void
TRANSPOSE::debug_print() const
{
        cout << "TRANSPOSE base class" << endl;
}

ExprType_t
TRANSPOSE::getType() const
{
  return TRANSPOSE_ENUM;
}


/**
 * CTRANSPOSE node
 */

CTRANSPOSE::CTRANSPOSE(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

CTRANSPOSE::Ptr
CTRANSPOSE::create(const OGNumeric::Ptr& arg)
{
  return CTRANSPOSE::Ptr{new CTRANSPOSE{arg}};
}

OGNumeric::Ptr
CTRANSPOSE::copy() const
{

  return OGNumeric::Ptr{new CTRANSPOSE(_args[0]->copy())};
}

CTRANSPOSE::Ptr
CTRANSPOSE::asCTRANSPOSE() const
{
  return static_pointer_cast<const CTRANSPOSE, const OGNumeric>(shared_from_this());
}

void
CTRANSPOSE::debug_print() const
{
        cout << "CTRANSPOSE base class" << endl;
}

ExprType_t
CTRANSPOSE::getType() const
{
  return CTRANSPOSE_ENUM;
}

/**
 * SVD node
 */

SVD::SVD(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

SVD::Ptr
SVD::create(const OGNumeric::Ptr& arg)
{
  return SVD::Ptr{new SVD{arg}};
}

OGNumeric::Ptr
SVD::copy() const
{
  return OGNumeric::Ptr{new SVD(_args[0]->copy())};
}

SVD::Ptr
SVD::asSVD() const
{
  return static_pointer_cast<const SVD, const OGNumeric>(shared_from_this());
}

void
SVD::debug_print() const
{
  cout << "SVD node" << endl;
}

ExprType_t
SVD::getType() const
{
  return SVD_ENUM;
}

/**
 * LU node
 */

LU::LU(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

LU::Ptr
LU::create(const OGNumeric::Ptr& arg)
{
  return LU::Ptr{new LU{arg}};
}

OGNumeric::Ptr
LU::copy() const
{
  return OGNumeric::Ptr{new LU(_args[0]->copy())};
}

LU::Ptr
LU::asLU() const
{
  return static_pointer_cast<const LU, const OGNumeric>(shared_from_this());
}

void
LU::debug_print() const
{
  cout << "LU node" << endl;
}

ExprType_t
LU::getType() const
{
  return LU_ENUM;
}


/**
 * MTIMES node
 */

MTIMES::MTIMES(const OGNumeric::Ptr& arg0, const OGNumeric::Ptr& arg1): OGBinaryExpr{arg0, arg1} {}

MTIMES::Ptr
MTIMES::create(const OGNumeric::Ptr& arg0, const OGNumeric::Ptr& arg1)
{
  return MTIMES::Ptr{new MTIMES{arg0, arg1}};
}


OGNumeric::Ptr
MTIMES::copy() const
{
  return OGNumeric::Ptr{new MTIMES(_args[0]->copy(), _args[1]->copy())};
}

MTIMES::Ptr
MTIMES::asMTIMES() const
{
  return static_pointer_cast<const MTIMES, const OGNumeric>(shared_from_this());
}

void
MTIMES::debug_print() const
{
        cout << "MTIMES base class" << endl;
}

ExprType_t
MTIMES::getType() const
{
  return MTIMES_ENUM;
}


/**
 * MLDIVIDE node
 */

MLDIVIDE::MLDIVIDE(const OGNumeric::Ptr& arg0, const OGNumeric::Ptr& arg1): OGBinaryExpr{arg0, arg1} {}

MLDIVIDE::Ptr
MLDIVIDE::create(const OGNumeric::Ptr& arg0, const OGNumeric::Ptr& arg1)
{
  return MLDIVIDE::Ptr{new MLDIVIDE{arg0, arg1}};
}


OGNumeric::Ptr
MLDIVIDE::copy() const
{
  return OGNumeric::Ptr{new MLDIVIDE(_args[0]->copy(), _args[1]->copy())};
}

MLDIVIDE::Ptr
MLDIVIDE::asMLDIVIDE() const
{
  return static_pointer_cast<const MLDIVIDE, const OGNumeric>(shared_from_this());
}

void
MLDIVIDE::debug_print() const
{
        cout << "MLDIVIDE base class" << endl;
}

ExprType_t
MLDIVIDE::getType() const
{
  return MLDIVIDE_ENUM;
}


/**
 * QR node
 */

QR::QR(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

QR::Ptr
QR::create(const OGNumeric::Ptr& arg)
{
  return QR::Ptr{new QR{arg}};
}

OGNumeric::Ptr
QR::copy() const
{
  return OGNumeric::Ptr{new QR(_args[0]->copy())};
}

QR::Ptr
QR::asQR() const
{
  return static_pointer_cast<const QR, const OGNumeric>(shared_from_this());
}

void
QR::debug_print() const
{
  cout << "QR node" << endl;
}

ExprType_t
QR::getType() const
{
  return QR_ENUM;
}

/**
 * SUMCOLS node
 */

SUMCOLS::SUMCOLS(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

SUMCOLS::Ptr
SUMCOLS::create(const OGNumeric::Ptr& arg)
{
  return SUMCOLS::Ptr{new SUMCOLS{arg}};
}

OGNumeric::Ptr
SUMCOLS::copy() const
{
  return OGNumeric::Ptr{new SUMCOLS(_args[0]->copy())};
}

SUMCOLS::Ptr
SUMCOLS::asSUMCOLS() const
{
  return static_pointer_cast<const SUMCOLS, const OGNumeric>(shared_from_this());
}

void
SUMCOLS::debug_print() const
{
  cout << "SUMCOLS node" << endl;
}

ExprType_t
SUMCOLS::getType() const
{
  return SUMCOLS_ENUM;
}


/**
 * SUMROWS node
 */

SUMROWS::SUMROWS(const OGNumeric::Ptr& arg): OGUnaryExpr{arg} {}

SUMROWS::Ptr
SUMROWS::create(const OGNumeric::Ptr& arg)
{
  return SUMROWS::Ptr{new SUMROWS{arg}};
}

OGNumeric::Ptr
SUMROWS::copy() const
{
  return OGNumeric::Ptr{new SUMROWS(_args[0]->copy())};
}

SUMROWS::Ptr
SUMROWS::asSUMROWS() const
{
  return static_pointer_cast<const SUMROWS, const OGNumeric>(shared_from_this());
}

void
SUMROWS::debug_print() const
{
  cout << "SUMROWS node" << endl;
}

ExprType_t
SUMROWS::getType() const
{
  return SUMROWS_ENUM;
}

} // namespace librdag
