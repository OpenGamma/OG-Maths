%
% Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies
%
% Please see distribution for license.
%

%
% This script will generate the unit test code for "safe" functions (those which don't change
% domain depending on numerical value of input).
%
% To generate the test code run:
% ${PATH_TO_MCODE_BINARY} testgen.m
%
% Output location (defaults to ${OG_MATHS_ROOT}/librdag/test/nodes/)
% is influenced by the 'outdir' variable set below.
%


clear all; close all; clc;

%% output dir
outdir='../../librdag/test/nodes/';

%% Template for all generated code
bsx_str = "...
/**\\n...
 * Copyright (C) 2014 - present by OpenGamma Inc. and the OpenGamma group of companies\\n...
 *\\n...
 * Please see distribution for license.\\n...
 */\\n...
// NOTE: This code is autogenerated, see src/generator/scripts/testgen.m\n ...
\\n...
#include \"gtest/gtest.h\"\\n...
#include \"terminal.hh\"\\n...
#include \"execution.hh\"\\n...
#include \"dispatch.hh\"\\n...
#include \"testnodes.hh\"\\n...
\\n...
using namespace std;\\n...
using namespace librdag;\\n...
using namespace testnodes;\\n...
using ::testing::TestWithParam;\\n...
using ::testing::Values;\\n...
\\n...
/**\\n...
 * Check __NODE_NAME__ node behaves\\n...
 */\\n...
\\n...
__NODE_TYPE___NODE_TEST_SETUP(__NODE_NAME__)\\n...
\\n...
INSTANTIATE_NODE_TEST_CASE_P(__NODE_NAME__Tests,__NODE_NAME__,\\n...
Values\\n...
(\\n...
__TEST_CASES__\\n...
)\\n...
);\\n...
\\n";

%% Data for the functions
rand('state',1:625); % reset RNG
data.trig_range=linspace(-6.25,6.25,11);
data.invtrig_range=linspace(-0.99,0.99,10);
data.perm_invtrig_range=data.invtrig_range(randperm(length(data.invtrig_range)));

data.hyp_range=linspace(-5,5,21);
data.acosh_range=linspace(1.01,10,10);
data.asinh_range=linspace(-10,10,10);
data.atanh_range=linspace(-0.99,0.99,10);

data.std_range_small = [-10:0.5:-0.5,0.5:0.5:10]; %% shift for things like div so theres no 0/0
data.std_range_large = 10*data.std_range_small;
data.std_const = 10;

data.lgamma_range = [0.5:0.5:10];
data.tgamma_range = [-9.5:2:-0.5,0.5:0.5:4];

data.log_range_small = 0.5+(0:0.5:10); %% shift to avoid 0
data.exp_range_small = -5:5;

data.pow_range_small = [-8:1:-1,0.5:0.5:4]; 
data.std_pow_const = 3;

data.bounded_one_one = linspace(-1,1,20);

[x,y]=meshgrid([-7:1:7],[-7:1:7]);
data.complex_data=x+i*y;
data.complex_data=reshape(data.complex_data,1,numel(data.complex_data));
data.complex_std_const = 10+5i;
data.complex_std_const_small = 1+2i;

% Gen for the safe functions
functions = {

% Struct form:
%{DOGMA name,m name,real space test range, [optional] complex space test range}

  % trig
  {'acos','acos',data.invtrig_range, data.complex_data},
  {'asin','asin',data.invtrig_range, data.complex_data},
  {'atan','atan',data.invtrig_range, data.complex_data+sqrt(2)},
  {'cos','cos',data.trig_range, data.complex_data},
  {'sin','sin',data.trig_range, data.complex_data},
  {'tan','tan',data.trig_range, data.complex_data},
   %exp+log
  {'exp','exp',data.exp_range_small,data.complex_data},
  {'expm1','expm1',data.exp_range_small},
  {'log','log',data.log_range_small,data.complex_data+sqrt(2)},
  {'log10','log10',data.log_range_small,data.complex_data+sqrt(2)},
  {'log1p','log1p',data.log_range_small},
  %hyp
  {'acosh','acosh',data.acosh_range,data.complex_data},
  {'asinh','asinh',data.asinh_range,data.complex_data},
  {'atanh','atanh',data.atanh_range,data.complex_data+sqrt(2)},
  {'cosh','cosh',data.hyp_range,data.complex_data},
  {'sinh','sinh',data.hyp_range,data.complex_data},
  {'tanh','tanh',data.hyp_range,data.complex_data},
  %specfun
  {'normcdf','normcdf',data.bounded_one_one},
  {'erf','erf',data.bounded_one_one},
  {'erfc','erfc',data.bounded_one_one},
  {'gammaln','lgamma',data.lgamma_range},
  {'gamma','gamma',data.tgamma_range},
  %  %PWR
  {'cbrt','cbrt',data.std_range_small},
  {'invsingle','invsingle',data.std_range_small}, % we use our own fn as inv returns 2 args, one is the rcond no
  {'sqrt','sqrt',data.log_range_small,data.complex_data},
  % ROUNDING
  {'ceil','ceil',data.trig_range},
  {'floor','floor',data.trig_range},
  {'round','round',data.trig_range},
  {'fix','fix',data.trig_range}

%% unimplemented functions
%  {''}, % RESERVED for cdfnorminv, not sure whether it's worth impl ATM
%  {''}, % RESERVED for erfinv, not sure whether it's worth impl ATM
%  {''}, % RESERVED for erfcinv, not sure whether it's worth impl ATM

%% functions that need special treatment
%    {'atan2','atan2',data.invtrig_range, data.perm_invtrig_range},
%    {'sincos','sincos',data.trig_range},
%    {'modf','modf',data.trig_range},
%    {'hypot','hypot',data.std_range_small, data.std_range_large},
%    {'power','power', data.pow_range_small, data.pow_range_small,data.complex_data(data.complex_data~=0),data.complex_data(data.complex_data~=0)/10},

%% possible dead functions
%    {'invcbrt','invcbrt',data.std_range_small},
%    {'invsqrt','invsqrt',data.log_range_small},
%    {'nearbyint','nearbyint',data.trig_range},
%    {'nearbyint','rint',data.trig_range},

};

% generate code
for k = 1:length(functions)
  loc_bsx_fn_str = bsx_str;
  ops = functions{k}{1};
  infix_tests = gen_bsx_function_tests(functions{k});
  loc_bsx_fn_str=strrep(loc_bsx_fn_str, '__NODE_TYPE__', 'UNARY');
  loc_bsx_fn_str=strrep(loc_bsx_fn_str, '__NODE_NAME__', upper(ops));
  loc_bsx_fn_str=strrep(loc_bsx_fn_str, '__TEST_CASES__', infix_tests);
  fname = ['check_',ops,'.cc'];
  fp=fopen([outdir,fname],'w+');
  if(fp<0)
    error(['file open failed for:', fname]);
  end
  fprintf(fp,loc_bsx_fn_str);
  fclose(fp);
end

%% Data and gen for the infix operators

% list of operators
ops = {'plus','minus','times','rdivide'};

% scalar
data.rs1.val = 7;                   % real scalar
data.rs1.str = 'real scalar';
data.cs1.val = 5+11i;               % complex scalar
data.cs1.str = 'complex scalar';

% vectors
data.rcv4.val = [1:4]';              % real col vector
data.rcv4.str = 'real length 4 column vector';
data.rcv5.val = [1:5]';              % real col vector
data.rcv5.str = 'real length 5 column vector';
data.rrv4.val = [4:-1:1];            % real row vector
data.rrv4.str = 'real length 4 row vector';
data.rrv5.val = [5:-1:1];            % real row vector
data.rrv5.str = 'real length 5 row vector';
data.ccv4.val = [1:4]'+[4:-1:1]'*i;  % complex col vector
data.ccv4.str = 'complex length 4 column vector';
data.ccv5.val = [1:5]'+[5:-1:1]'*i;  % complex col vector
data.ccv5.str = 'complex length 5 column vector';
data.crv4.val = [4:-1:1]+[1:4]*i;    % complex row vector
data.crv4.str = 'complex length 4 row vector';
data.crv5.val = [5:-1:1]+[1:5]*i;    % complex row vector
data.crv5.str = 'complex length 5 row vector';

% matrices
data.r5x4.val = toeplitz(data.rcv5.val,data.rrv4.val);
data.r5x4.str = 'real 5x4 matrix';
data.r4x5.val = toeplitz(data.rcv4.val,data.rrv5.val);
data.r4x5.str = 'real 4x5 matrix';
data.c5x4.val = toeplitz(data.ccv5.val,data.crv4.val);
data.c5x4.str = 'complex 5x4 matrix';
data.c4x5.val = toeplitz(data.ccv4.val,data.crv5.val);
data.c4x5.str = 'complex 4x5 matrix';

% generate code
for k=1:length(ops)
  loc_bsx_infix_str = bsx_str;
  infix_tests = gen_bsx_infix_tests(ops{k}, data);
  loc_bsx_infix_str=strrep(loc_bsx_infix_str, '__NODE_TYPE__', 'BINARY');
  loc_bsx_infix_str=strrep(loc_bsx_infix_str, '__NODE_NAME__', upper(ops{k}));
  loc_bsx_infix_str=strrep(loc_bsx_infix_str, '__TEST_CASES__', infix_tests);
  fname = ['check_',ops{k},'.cc'];
  fp=fopen([outdir,fname],'w+');
  if(fp<0)
    error(['file open failed for:', fname]);
  end
  fprintf(fp,loc_bsx_infix_str);
  fclose(fp);
end